---
title: "IPTW"
author: "David Cavallucci"
date: "6 August 2015"
output: 
  html_document: 
    theme: journal
---

#Load libraries

The following libraries are loaded as well as some custom R scripts.
```{r,results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE}
#library(miceadds)
library(gdata)
library(readxl)
library(readr)
library(ggplot2)
library(ggthemes)
library(survival)
library(lubridate)
library(mice)
library(mitools)
library(twang)
library(dplyr)
library(tidyr)
library(magrittr)
library(knitr)
library(stringr)
library(rlist)
#library(grid)
library(scales)
library(broom)
library(pander)
source("utilities.R")
panderOptions("table.split.table", Inf)
```

#Import, clean-up

The dataset is imported and tidied, interim datasets are removed.
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
source("data_tidying.R")
rm(raw, dif_segs, id_twostage)

```


```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE, cache=TRUE}
library(mice)
imp <- mice(as.data.frame(subnew), method="cart", maxit=10)
```

#Heat map of missing data patterns

The initial missing data analysis is shown via a heatmap and table of missing values.
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}

#Visualise missing data
library(mi)
subnew %>% dplyr::select(-primaryM) -> mi.data
mdf <- missing_data.frame(as.data.frame(mi.data))
image(mdf)
detach(package:mi)

```

<br>

##Table of missing data 
```{r,  results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
kable(data.frame(row.names = names(imp$nmis), missing=(imp$nmis), percent = round(imp$nmis/284*100, 0)), col.names = c("Number missing", "Percent missing"))
```


#Multiple imputation using chained equations

The default of five imputations are obtained using ten iterations for each. The classification and regression tree method is used.

`imp <- mice(as.data.frame(subnew), method="cart", maxit=10)`

<br>

```{r,  results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#This is a post-imputation cleanup. The primary tumour/treatment details are standardised for the small group with multiple operations. It would be non-sensical to use different values of these for the same patient.
imptmp <- mice::complete(imp, "long", include=TRUE)
imptmp %<>% group_by(.imp, id_patients) %>% mutate(
    primaryT=first(primaryT),
    primaryN=first(primaryN),
    primarytumourgrade=first(primarytumourgrade),
    primarytreatment=first(primarytreatment))
imptmp %<>% ungroup() %>% mutate(posmarg = ifelse(margin<1,1,0))
imptmp$posmarg <- as.factor(imptmp$posmarg)

#A new mids object is created
impmids <- as.mids(as.data.frame(imptmp))

```

<br>

#Estimate propensity scores for each imputed dataset
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
propscores <- vector("list")
for(i in 1:5) {
      tmp <- ps(lap~age+sex+CEA+ismajor+difloc+isbilateral+lesionmaxdiameter+lesioncount+primarytumourgrade+primaryT+primaryN+year_primary+primarytreatment, estimand = "ATE", data=mice::complete(impmids,i), interaction.depth=2, n.trees = 10000, shrinkage=0.01, verbose=FALSE, bag.fraction = 0.3, stop.method = "ks.max")
      propscores[[paste("psate",i,sep="")]] <- tmp
}

```

<br>

Generate stabilised weights for each imputed dataset. Stabilised weights are generated by dividing the weight calculated by inverse propensity score by the average weight for the sample. Additionally, generate an interim list of weights (impweights) for upcoming plot.

<br>

```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE}
impdata <- vector("list")
impweights <- vector("list")
impdata[["psate0"]] <- as.data.frame(subnew)
impdata[["psate0"]]$stable.w <- 1

  for (i in 1:5) {
      name <- paste("psate",i,sep="")
      impdata[[name]] <- mice::complete(impmids,i)
      impdata[[name]]$stable.w <- stable.weights(propscores[[i]], "ks.max")
      impweights[[name]] <- data.frame(weights=stable.weights(propscores[[i]], "ks.max"), treat=propscores[[i]]$treat, id=propscores[[i]]$data$id_patients)
}

```

<br>

#Plots and balance computations for each imputed dataset
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}

plotweights <- data.frame(weights=c(unlist(list.map(impweights, weights))), treat=c(unlist(list.map(impweights, treat))), imp=rep(1:5, each=length(impweights$psate1$weights)), id=c(unlist(list.map(impweights, id))))

#Boxplot of weights
ggplot(plotweights, aes(factor(treat), weights, fill=factor(treat))) + geom_boxplot() + facet_wrap(~imp) + scale_fill_fivethirtyeight(labels = c("Open", "Laparoscopic")) + guides(fill=guide_legend(title=NULL)) + ggtitle("Distribution of stabilised weights for each imputed dataset")+ xlab("") + ylab("Stabilised weights") +  theme_bw() + theme(axis.text.x = element_blank())

#histogram of weights
#ggplot(plotweights, aes(weights, fill= as.factor(treat))) + geom_histogram() + facet_wrap(~imp) + scale_fill_fivethirtyeight(labels = c("Open", "Laparoscopic")) + guides(fill=guide_legend(title=NULL)) + ggtitle("Distribution of stabilised weights for each imputed dataset") 

source("new_balance_plots.R")
```


#Balance tables and balance plots for each imputed dataset
```{r, results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
for (i in 1:5) {
  print(kable(cbind(round(ballist[[i]]$unw[,c("tx.mn", "ct.mn","std.eff.sz", "p")],2), round(ballist[[i]]$wtd[,c("tx.mn", "ct.mn","std.eff.sz", "p")],2)), align = 'l', caption = str_c("Dataset number ", i)))
}
```

```{r,results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}

for (i in 1:5) {
  print(balplotlist[[i]])
  print(qqplotlist[[i]])
}

```


#Generate an "imputationList"" object from the data

This will allow the use of `mitools` to combine the results of analyses from the survey and other packages and account for the imputations using Rubin's rules. At this stage, we also construct some new compound variables - the number of laparoscopic procedures, calculation of the "gaptime" and a marker for death OR recurrence.

```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE}

mit <- impdata[2:6]

for (i in 1:5) {
  mit[[i]] %>% group_by(id_patients) %>%
    mutate(ctime = ifelse(index<max(index),rtime,cens_time),
    numlap = sum(lap),
    cens_month = round(cens_time/365.25*12, digits = 1),
    gaptime = rtime-time,
    censrec = ifelse(index<max(index), 0, cens)) -> mit[[i]]
  mit[[i]]$numlap <- car::Recode(mit[[i]]$numlap, '2:4=2')
  mit[[i]]$index <- car::recode(mit[[i]]$index, '2:4=2')
  mit[[i]] %>% mutate(mhlos = hlos-mean(hlos, na.rm=T)) -> mit[[i]]
}

midata <- imputationList(mit)

```
<br>

The same variables are added to the original (unimputed, unweighted) dataset.
```{r,  results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#add required variables to "new" to allow for later comparisons
new <- new %>% group_by(id_patients) %>% 
  mutate(ctime = ifelse(index<max(index),rtime,cens_time),
         numlap = sum(lap),
         cens_month = round(cens_time/365.25*12, digits = 1),
         gaptime = rtime-time,
         censrec = ifelse(index<max(index), 0, cens))
new$ctime <- as.numeric(new$ctime)
new$numlap <- car::Recode(new$numlap, '2:4=2')
new$index <- car::recode(new$index, '2:4=2')
new %>% ungroup %>% mutate(posmarg = ifelse(margin<1,1,0)) -> new
new$posmarg <- as.factor(new$posmarg)
new %>% mutate(mhlos = hlos - mean(hlos, na.rm=T)) -> new
```

#Survey design

These design objects describe the data to the `survey` package so it can make appropriate adjustments to errors based on clustering and multiple imputation. It ensures that the standard error calculations are appropriate.
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE}

design.ate <- svydesign(ids = ~id_patients, weights=~stable.w, data=midata)
design.sing <- svydesign(ids = ~id_patients, weights=~stable.w, data=midata$imputations$psate1)
design.unw <- svydesign(ids = ~id_patients, data=midata)
```

----

#Demographics

##Code for demographics generation - makes extensive use of `dplyr`.
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE}
#Summarise distinct patient numbers and total procedure numbers by surgical approach
ptnumbers <- 
  new %>% 
  group_by(lap) %>% 
  summarise(
    patients = n_distinct(id_patients),
    procedures = n())
  

#Number of patients with single procedures
singlepts <- 
  new %>% 
  group_by(id_patients) %>% 
  filter(n()==1) %>% 
  nrow()

#Multiple procedures
multiplepts <- 
  new %>% 
  group_by(id_patients) %>% 
  filter(n()>1) %>% 
  tally() %>% 
  nrow()
 

procnum <- 
  matrix(c("Single procedures ", singlepts, "Multiple procedures ",
           multiplepts), nrow = 2, byrow = T)
colnames(procnum) <- c("Group", "n")


#Procedures and conversions
proc_list <- 
  new %>% 
  group_by(lap, surgicalapproach) %>% 
  tally()

proc_list <- proc_list[,2:3]

#Procedure type ---------------------

#Hepatectomies
majorhep <- 
  new %>% 
  filter(grepl("hepatectomy", liverprocs)) %>% 
  mutate(
    side= ifelse(grepl("left", liverprocs),
                 "left hepatectomy",
                 "right hepatectomy")) %>%
  group_by(lap, side) %>%
  tally() 
majorhep$lap <- car::recode(majorhep$lap, "1='Lap'; 0='Open'", as.factor.result=T)


#Left lateral
lls <- 
  new %>% 
  filter(grepl("left lateral", liverprocs),
         !grepl("hepatectomy", liverprocs)) %>% 
  group_by(lap) %>%
  tally() 
lls$lap <- car::recode(lls$lap, "1='Lap'; 0='Open'", as.factor.result=T) 

#Segmentectomy/biseg
segment <- new %>% 
  filter(grepl("segment", liverprocs),
         !grepl("hepatectomy", liverprocs),
         !grepl("left lateral", liverprocs)) %>% 
  group_by(lap) %>%
  tally()
segment$lap <- car::recode(segment$lap, "1='Lap'; 0='Open'", as.factor.result=T)
#Tumorectomy (only)
tumorectomy <- 
  new %>% 
  filter(!grepl("hepatectomy", liverprocs), !grepl("left lateral", liverprocs), 
         !grepl("segmentectomy", liverprocs)) %>% 
  group_by(lap) %>%
  tally()
tumorectomy$lap <- car::recode(tumorectomy$lap, "1='Lap'; 0='Open'", as.factor.result=T)
```

<br>

#Demographics Output

<br>

```{r, results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#Print demographics
kable(ptnumbers, col.names=c("Laparoscopic", "Patients", "Procedures"), align = 'l', caption = "Patients and Procedures")

kable(procnum, align = 'l', caption = "Multiple procedures")

kable(proc_list, col.names = c("Surgical approach", "n"), align = 'l', caption = "Surgical approach")

kable(majorhep, col.names = c("Laparoscopic", "Hepatectomy", "n"), caption = "Major hepatectomy", align = 'l')

kable(lls, col.names = c("Laparoscopic", "n"), caption = "Left lateral sectionectomy", align = 'l')

kable(segment, col.names = c("Laparoscopic", "n"), caption = "Segmentectomy/Bisegmentectomy", align = 'l')

kable(tumorectomy, col.names = c("Laparoscopic", "n"), caption = "Tumorectomy", align = 'l')
```

#Changes in operative approach over time.
```{r}
#Year-by-year histogram
new$year <- year(new$opdate)
new$year <- as.factor(new$year)
new %>% group_by(ismajor,lap,year) %>% tally() -> testgraph
testgraph %>% filter(as.character(year)>"1999") -> testgraph
ggplot(testgraph, aes(x=year, y=n, fill=interaction(lap,ismajor))) + geom_histogram(stat="identity") + scale_fill_manual(labels=c("open minor", "lap minor", "open major", "lap major"), name="Procedure type", values = c("royalblue1", "blue4","lightgreen", "green4")) + theme_gdocs() + ggtitle("Operative approach: year-by-year change")

```

#Code for generation of weighted statistics
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE}
#Setup for unw vs wtd periop outcomes - Bloodloss, LOS, operative time and margin (posmarg separate)

#weighted, pooled(MI) data
postopwtd <- MIcombine(with(design.ate, svyby(~bloodloss+hlos+optime+margin, ~lap,svyquantile, quantiles=0.5, ci=TRUE, vartype = "var")))

#unweighted, pooled data
postopunw <- MIcombine(with(design.unw, svyby(~bloodloss+hlos+optime+margin, ~lap,svyquantile, quantiles=0.5, ci=TRUE, vartype = "var")))

#----------------------

#Positive margin - get proportions, then compare props and extract P-value

#Weighted
posmargwtd <- MIcombine(with(design.ate, svyby(~posmarg, ~lap, svyciprop, vartype="var")))

#Rubins rule - manual calculation of the Chi-squared statistic for comparison of proportions
X2wtd <- sum(mapply(function(x) x$statistic, lapply(with(design.ate, svytable(~lap + posmarg, Ntotal = 284, round = T)), prop.test)))/5

#Unweighted
posmargunw <- MIcombine(with(design.unw, svyby(~posmarg, ~lap, svyciprop, vartype="var")))

#Rubins rule
X2unw <- sum(mapply(function(x) x$statistic, lapply(with(design.unw, svytable(~lap + posmarg, Ntotal = 284, round = T)), prop.test)))/5

```

#Results of Weighted univariate analysis
```{r,results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
pander(summary.MIresult(postopwtd, digits = 2))

```

#Results of Unweighted univariate analysis
```{r,results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}

pander(summary.MIresult(postopunw, digits = 2))
```

#Results of Weighted margin status
```{r,results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}

pander(summary.MIresult(posmargwtd, digits =2), caption = str_c("p = ", round(pchisq(X2wtd, 1, lower.tail = F),3)))
  
```

#Results of Unweighted margin status
```{r,results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}

pander(summary.MIresult(posmargunw, digits = 2), caption = str_c("p = ", round(pchisq(X2unw, 1, lower.tail = F),3)))
  
```

<br>

#Kaplan-Meier survival estimates and follow-up
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#Cohort Median follow-up time by KMPF (reverse kaplan meier method)
with(midata,survfit(Surv(cens_time, cens==0)~1+cluster(id_patients), weights = stable.w, subset=index==1)) %>%
  list.apply(summary) %>%
  list.map(table) %>%
  list.mapv(median) %>%
  {
    mfu <-round(sum(.)/5/365.25*12, 2)
    str_c("Median follow-up (reverse KM method): ",mfu," months")
  } -> mfu

#Cohort Median OS
with(midata,survfit(Surv(cens_time, cens)~cluster(id_patients), weights = stable.w, subset=index==1)) %>%
  list.apply(summary) %>%
  list.map(table) %>%
  list.mapv(median) %>%
  {
    os <-round(sum(.)/5/365.25*12, 2)
    str_c("Median OS (cohort): ",os," months")
  } -> cohortmedos


pool.kmos <- with(midata,survfit(Surv(cens_time, cens)~lap+cluster(id_patients), weights = stable.w, subset=index==1))

#OS---------------
#Median OS in output results

#OS Peto-Peto modification of Gehan-Wilcoxon test (log rank), lichtrub p-val test (not perfect)
lros <- with(design.ate, svylogrank(Surv(cens_time, cens)~lap))

#5yr OS
pool.km5yr <- list.apply(pool.kmos, summary, times=1826.25)
pool5.open <- pool.scalar(list.mapv(pool.km5yr, surv[1]), list.mapv(pool.km5yr, std.err[1]^2), method="rubin")
pool5.lap <- pool.scalar(list.mapv(pool.km5yr, surv[2]), list.mapv(pool.km5yr, std.err[2]^2), method="rubin")
fiveyropen <- mi.ci(pool5.open)
fiveryrlap <- mi.ci(pool5.lap)

#------------------OS

#RFS-----------------
#RFS strata by index - gaptime is what we want to know - recurrence after each operation
rfskm <- with(midata, survfit(Surv(gaptime, (rec==1|censrec==1))~lap + strata(index) +cluster(id_patients), weights = stable.w))

cohortrfs <- with(midata, survfit(Surv(gaptime, (rec==1|censrec==1))~strata(index) +cluster(id_patients), weights = stable.w))


#logrank RFS
lrrfs <- with(design.ate, svylogrank(Surv(gaptime, (rec==1|censrec==1))~lap+strata(index)))


#5yr RFS
pool.rfs <- list.apply(rfskm, summary, times=1826.25)
pool5rfs.open <- pool.scalar(list.mapv(pool.rfs, surv[1]), list.mapv(pool.rfs, std.err[1]^2), method="rubin")
pool5rfs.lap <- pool.scalar(list.mapv(pool.rfs, surv[2]), list.mapv(pool.rfs, std.err[2]^2), method="rubin")
fiveyropenrfs <- mi.ci(pool5rfs.open)
fiveryrlaprfs <- mi.ci(pool5rfs.lap)

#--------------RFS

#Procedure based recurrence risk-------

#compare only the first OR only the second procedures - km, weighted log-rank, combined chisq
ind1 <- subset(design.ate, index==1) 
ind2 <- subset(design.ate, index==2)

rfs.km.ind1 <- with(midata, survfit(Surv(gaptime, (rec==1|censrec==1))~lap+cluster(id_patients), subset=index==1, weights=stable.w))

rfs.ind1 <- with(ind1, svylogrank(Surv(gaptime, (rec==1|censrec==1))~lap))


rfs.km.ind2 <- with(midata, survfit(Surv(gaptime, (rec==1|censrec==1))~lap+cluster(id_patients), subset=index==2, weights=stable.w))

rfs.ind2 <- with(ind2, svylogrank(Surv(gaptime, (rec==1|censrec==1))~lap))


```


```{r, results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#Median FU
pander(mfu)

#OS
pander(cohortmedos)
pander(pool.km(pool.kmos), style="rmarkdown")
pander(cavcombine(list.mapv(list.map(lros, list.extract(.,2)),chisq),1))


str_c("Open ", fiveyropen, "\n")
str_c("Laparoscopic ", fiveryrlap)

#Median RFS 
pander(pool.km(rfskm), caption = "Kaplan-Meier RFS", style="rmarkdown")
pander(cavcombine(list.mapv(list.map(lrrfs, list.extract(.,2)),chisq),1))

#5yr RFS
pander(str_c("Open ", fiveyropenrfs))
pander(str_c("Laparoscopic ", fiveryrlaprfs))

#RFS by procedure number
#Index 1
pander(pool.km(rfs.km.ind1))
pander(cavcombine(list.mapv(list.map(rfs.ind1, list.extract(.,2)),chisq),1))
#Index2
pander(pool.km(rfs.km.ind2))
pander(cavcombine(list.mapv(list.map(rfs.ind2, list.extract(.,2)),chisq),1))

```

#Weighted regression
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#OS-------------
#For the double robust - compare the "full model" correcting for all vars >0.2 in the PS model vs treatment only model.

#Full model
doublerobust.full <- with(midata, coxph(Surv(time, ctime,censrec)~lap+cluster(id_patients)+ismajor+isbilateral+primaryN+primaryT+lesioncount, weights = stable.w))

#Rx only model
doublerobust.final <- with(midata, coxph(Surv(time, ctime,censrec)~lap+cluster(id_patients), weights = stable.w))

#Reduced model
#doublerobust.final <- with(midata, coxph(Surv(time, ctime,censrec)~lap+cluster(id_patients)+primaryT, weights = stable.w))



#OS---------------


#RFS - PWP-CT model-------------
rec_double.full <- with(midata, coxph(Surv(gaptime,(rec==1|censrec==1))~lap+ismajor+isbilateral+primaryN+lesioncount+primaryT + strata(index), weights = stable.w))

rec_double.final <- with(midata, coxph(Surv(gaptime,(rec==1|censrec==1))~lap + strata(index), weights = stable.w))


#RFS-----------------------------

#Multivariate models------------
mvr.os  <- with(midata, coxph(Surv(time, ctime,censrec)~lap+cluster(id_patients)+ismajor+isbilateral+primaryN+lesioncount+primaryT+bloodloss+mhlos+optime+posmarg, weights = stable.w))

mvr.os.raw <- coxph(Surv(time, ctime,censrec)~lap+cluster(id_patients)+ismajor+isbilateral+primaryN+lesioncount+primaryT+bloodloss+mhlos+optime+posmarg, data=new)

mvr.rfs <- with(midata, coxph(Surv(gaptime,(rec==1|censrec==1))~lap+cluster(id_patients)+ismajor+isbilateral+primaryN+lesioncount+primaryT+bloodloss+mhlos+optime+strata(index)+posmarg, weights = stable.w))

mvr.rfs.raw <- coxph(Surv(gaptime,(rec==1|censrec==1))~lap+cluster(id_patients)+ismajor+isbilateral+primaryN+lesioncount+primaryT+bloodloss+mhlos+optime+strata(index)+posmarg, data=new)
#------------------------------

########Final multivariate models

os_final <- with(midata, coxph(Surv(time, ctime,cens)~cluster(id_patients)+primaryT+posmarg+lap+lesioncount, weights = stable.w))

raw.os.final <- coxph(Surv(time, ctime, cens)~cluster(id_patients)+primaryT+posmarg+lap+lesioncount, data=new)

era.os.final <- with(midata, coxph(Surv(time,ctime,cens)~cluster(id_patients)+primaryT+posmarg+lap+lesioncount, weights = stable.w, subset=era==1))

#------------------

rfs_final <- with(midata, coxph(Surv(gaptime, (rec==1|censrec==1))~cluster(id_patients)+primaryT+posmarg+mhlos+lap, weights = stable.w))

raw.rfs.final <- coxph(Surv(gaptime, (rec==1|censrec==1))~cluster(id_patients)+primaryT+posmarg+mhlos+lap, data=new)

era.rfs.final <- with(midata, coxph(Surv(gaptime, (rec==1|censrec==1))~cluster(id_patients)+primaryT+posmarg+mhlos+lap, weights = stable.w, subset=era==1))
###Print setup

os.final.data <- plotdf(os_final)
raw.os.final.data <- plotdf(raw.os.final)
era.os.final.data <- plotdf(era.os.final)

rfs.final.data <- plotdf(rfs_final)
raw.rfs.final.data <- plotdf(raw.rfs.final)
era.rfs.final.data <- plotdf(era.rfs.final)

```

```{r}
pander(spm(doublerobust.full)) #full os doublerobust
pander(spm(doublerobust.final)) #final os double robust

pander(spm(rec_double.full)) #full Rfs doublerobust
pander(spm(rec_double.final)) #final rfs double robust

pander(spm(mvr.os)) #full os multivar 
pander(mvr.os.raw) #full rfs multivar
pander(spm(mvr.rfs))
pander(mvr.rfs.raw)

pander(spm(os_final)) #final os multivar
pander(spm(rfs_final)) #final rfs multivar

```


#Regression output
```{r, results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#kable(os.final.data[,c(2,6,7,8)], align = 'l')
#kable(rfs.final.data[,c(2,6,7,8)], align = 'l')
source("new_os_surv_curv.R")
source("new_rfs_surv_curv.R")
os_curve
rfs_curve
```