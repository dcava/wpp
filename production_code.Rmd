---
title: "IPTW"
author: "David Cavallucci"
date: "7 May 2015"
output: 
  html_document: 
    theme: readable
---

#Load libraries

The following libraries are loaded as well as some custom R scripts.
```{r,results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE}
library(gdata)
library(readxl)
library(readr)
library(ggplot2)
library(ggthemes)
library(survival)
library(lubridate)
library(mice)
library(mitools)
library(twang)
library(dplyr)
library(tidyr)
library(magrittr)
library(knitr)
library(stringr)
library(rlist)
library(grid)
library(scales)
library(broom)
library(pander)
source("utilities.R")
source("stable.weights.R")
panderOptions("table.split.table", Inf)
```

#Import, clean-up

The dataset is imported and tidied, interim datasets are removed.
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
source("data_tidying.R")
rm(raw, dif_segs, id_twostage)

```


```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE, cache=TRUE}
library(mice)
imp <- mice(as.data.frame(subnew), method="cart", maxit=10)
```

#Heat map of missing data patterns

The initial missing data analysis is shown via a heatmap and table of missing values.
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}

#Visualise missing data
library(mi)
subnew %>% dplyr::select(-primaryM) -> mi.data
mdf <- missing_data.frame(as.data.frame(mi.data))
image(mdf)
detach(package:mi)

```

```{r,  results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
kable(cbind(data.frame(imp$nmis), percent = round(data.frame(imp$nmis)$imp.nmis/284*100, 0)))
```


#Multiple imputation using chained equations

The default of five imputations are obtained using ten iterations for each. The classification and regression tree method is used.

`imp <- mice(as.data.frame(subnew), method="cart", maxit=10)`


```{r,  results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#This is a post-imputation cleanup. The primary tumour/treatment details are standardised for the small group with multiple operations. It would be non-sensical to use different values of these for the same patient.

imptmp <- complete(imp, "long", include=TRUE)
imptmp %<>% group_by(.imp, id_patients) %>% mutate(
    primaryT=first(primaryT),
    primaryN=first(primaryN),
    primarytumourgrade=first(primarytumourgrade),
    primarytreatment=first(primarytreatment))
imptmp %<>% ungroup() %>% mutate(posmarg = ifelse(margin<1,1,0))
imptmp$posmarg <- as.factor(imptmp$posmarg)

#A new mids object is created
impmids <- as.mids(as.data.frame(imptmp))

```

#Estimate propensity scores for each imputed dataset
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE, cache=TRUE}
propscores <- vector("list")
for(i in 1:5) {
      tmp <- ps(lap~age+sex+CEA+ismajor+difloc+isbilateral+lesionmaxdiameter+lesioncount+primarytumourgrade+primaryT+primaryN+year_primary+primarytreatment, estimand = "ATE", data=complete(impmids,i), interaction.depth=2, n.trees = 10000, shrinkage=0.01, verbose=FALSE, bag.fraction = 0.3, stop.method = "ks.max")
      propscores[[paste("psate",i,sep="")]] <- tmp
}

```


Generate stabilised weights for each imputed dataset, generate an interim list (impweights) for upcoming plot.
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE}
impdata <- vector("list")
impweights <- vector("list")
impdata[["psate0"]] <- as.data.frame(subnew)
impdata[["psate0"]]$stable.w <- 1

  for (i in 1:5) {
      name <- paste("psate",i,sep="")
      impdata[[name]] <- complete(impmids,i)
      impdata[[name]]$stable.w <- stable.weights(propscores[[i]], "ks.max")
      impweights[[name]] <- data.frame(weights=stable.weights(propscores[[i]], "ks.max"), treat=propscores[[i]]$treat, id=propscores[[i]]$data$id_patients)
}

```

#Plots and balance computations for each imputed dataset
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}

plotweights <- data.frame(weights=c(unlist(list.map(impweights, weights))), treat=c(unlist(list.map(impweights, treat))), imp=rep(1:5, each=length(impweights$psate1$weights)), id=c(unlist(list.map(impweights, id))))

#Boxplot of weights
ggplot(plotweights, aes(factor(treat), weights, fill=factor(treat))) + geom_boxplot() + facet_wrap(~imp) + scale_fill_fivethirtyeight(labels = c("Open", "Laparoscopic")) + guides(fill=guide_legend(title=NULL)) + ggtitle("Distribution of stabilised weights for each imputed dataset")+ xlab("") + ylab("Stabilised weights") +  theme_bw() + theme(axis.text.x = element_blank())

#histogram of weights
#ggplot(plotweights, aes(weights, fill= as.factor(treat))) + geom_histogram() + facet_wrap(~imp) + scale_fill_fivethirtyeight(labels = c("Open", "Laparoscopic")) + guides(fill=guide_legend(title=NULL)) + ggtitle("Distribution of stabilised weights for each imputed dataset") 

source("new_balance_plots.R")
```


#Balance tables and balance plots for each imputed dataset
```{r, results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
for (i in 1:5) {
  print(kable(cbind(round(ballist[[i]]$unw[,c("tx.mn", "ct.mn","std.eff.sz", "p")],2), round(ballist[[i]]$wtd[,c("tx.mn", "ct.mn","std.eff.sz", "p")],2)), align = 'l', caption = str_c("Dataset number ", i)))
}
```

```{r,results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}

for (i in 1:5) {
  print(balplotlist[[i]])
  print(qqplotlist[[i]])
}

```


#Generate an "imputationList"" object from the data

This will allow the use of mitools to combine the results of analyses from the survey and other packages and account for the imputations using Rubin's rules. At this stage, we also construct some new compound variables.

```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE}

mit <- impdata[2:6]

for (i in 1:5) {
  mit[[i]] %>% group_by(id_patients) %>%
    mutate(ctime = ifelse(index<max(index),rtime,cens_time),
    numlap = sum(lap),
    cens_month = round(cens_time/365.25*12, digits = 1),
    gaptime = rtime-time,
    censrec = ifelse(index<max(index), 0, cens)) -> mit[[i]]
  mit[[i]]$numlap <- car::Recode(mit[[i]]$numlap, '2:4=2')
  mit[[i]]$index <- car::recode(mit[[i]]$index, '2:4=2')
  mit[[i]] %>% mutate(mhlos = hlos-mean(hlos, na.rm=T)) -> mit[[i]]
}

midata <- imputationList(mit)

```

```{r,  results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#add required variables to "new" to allow for later comparisons
new <- new %>% group_by(id_patients) %>% 
  mutate(ctime = ifelse(index<max(index),rtime,cens_time),
         numlap = sum(lap),
         cens_month = round(cens_time/365.25*12, digits = 1),
         gaptime = rtime-time,
         censrec = ifelse(index<max(index), 0, cens))
new$ctime <- as.numeric(new$ctime)
new$numlap <- car::Recode(new$numlap, '2:4=2')
new$index <- car::recode(new$index, '2:4=2')
new %>% ungroup %>% mutate(posmarg = ifelse(margin<1,1,0)) -> new
new$posmarg <- as.factor(new$posmarg)
new %>% mutate(mhlos = hlos - mean(hlos, na.rm=T)) -> new
```

#Survey design

These design objects describe the data to the survey package so it can make appropriate adjustments to errors based on the clustering and multiple imputation
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=TRUE}

design.ate <- svydesign(ids = ~id_patients, weights=~stable.w, data=midata)
design.sing <- svydesign(ids = ~id_patients, weights=~stable.w, data=midata$imputations$psate1)
design.unw <- svydesign(ids = ~id_patients, data=midata)
```



#Demographics


```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#Summarise distinct patient numbers and total procedure numbers by surgical approach
ptnumbers <- 
  new %>% 
  group_by(lap) %>% 
  summarise(
    patients = n_distinct(id_patients),
    procedures = n())
  

#Single ops
singlepts <- 
  new %>% 
  group_by(id_patients) %>% 
  filter(n()==1) %>% 
  nrow()

#multiples
multiplepts <- 
  new %>% 
  group_by(id_patients) %>% 
  filter(n()>1) %>% 
  tally() %>% 
  nrow()
 

procnum <- 
  matrix(c("Single procedures ", singlepts, "Multiple procedures ",
           multiplepts), nrow = 2, byrow = T)
colnames(procnum) <- c("Group", "n")


#Procedures and conversions
proc_list <- 
  new %>% 
  group_by(lap, surgicalapproach) %>% 
  tally()

#Procedure type ---------------------

#Hepatectomies
majorhep <- 
  new %>% 
  filter(grepl("hepatectomy", liverprocs)) %>% 
  mutate(
    side= ifelse(grepl("left", liverprocs),
                 "left hepatectomy",
                 "right hepatectomy")) %>%
  group_by(lap, side) %>%
  tally() 



#Left lateral
lls <- 
  new %>% 
  filter(grepl("left lateral", liverprocs),
         !grepl("hepatectomy", liverprocs)) %>% 
  group_by(lap) %>%
  tally() 
  
#Segmentectomy/biseg
segment <- new %>% 
  filter(grepl("segment", liverprocs),
         !grepl("hepatectomy", liverprocs),
         !grepl("left lateral", liverprocs)) %>% 
  group_by(lap) %>%
  tally()

#Tumorectomy (only)
tumorectomy <- 
  new %>% 
  filter(!grepl("hepatectomy", liverprocs), !grepl("left lateral", liverprocs), 
         !grepl("segmentectomy", liverprocs)) %>% 
  group_by(lap) %>%
  tally()

```


#Demographics Output
```{r, results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#Print demographics
pander(ptnumbers, col.names=c("Laparoscopic", "Patients", "Procedures"), align = 'l')
pander(procnum, align = 'l')
pander(proc_list[,2:3], col.names = c("Surgical approach", "n"), align = 'l')
pander(majorhep, col.names = c("Laparoscopic", "Hepatectomy", "n"), caption = "Major hepatectomy", align = 'l')
pander(lls, col.names = c("Laparoscopic", "n"), caption = "Left lateral sectionectomy", align = 'l')
pander(segment, col.names = c("Laparoscopic", "n"), caption = "Segmentectomy/Bisegmentectomy", align = 'l')
pander(tumorectomy, col.names = c("Laparoscopic", "n"), caption = "Tumorectomy", align = 'l')
```


```{r}
#Year-by-year histogram
new$year <- year(new$opdate)
new$year <- as.factor(new$year)
new %>% group_by(ismajor,lap,year) %>% tally() -> testgraph
testgraph %>% filter(as.character(year)>"1999") -> testgraph
ggplot(testgraph, aes(x=year, y=n, fill=interaction(lap,ismajor))) + geom_histogram(stat="identity") + scale_fill_manual(labels=c("open minor", "lap minor", "open major", "lap major"), name="Procedure type", values = c("royalblue1", "blue4","lightgreen", "green4")) + theme_gdocs()

```

#Weighted stats
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#Setup for unw vs wtd periop outcomes - Bloodloss, LOS, operative time and margin (posmarg separate)

#weighted, pooled, MI data - gets medians!
postopwtd <- MIcombine(with(design.ate, svyby(~bloodloss+hlos+optime+margin, ~lap,svyquantile, quantiles=0.5, ci=TRUE, vartype = "var")))

#unweighted, pooled MI data
postopunw <- MIcombine(with(design.unw, svyby(~bloodloss+hlos+optime+margin, ~lap,svyquantile, quantiles=0.5, ci=TRUE, vartype = "var")))

#----------------------

#Positive margin - get proportions, then compare props and extract P-value

#Weighted
posmargwtd <- MIcombine(with(design.ate, svyby(~posmarg, ~lap, svyciprop, vartype="var")))
#Rubins rule
X2wtd <- sum(mapply(function(x) x$statistic, lapply(with(design.ate, svytable(~lap + posmarg, Ntotal = 284, round = T)), prop.test)))/5

#Unweighted
posmargunw <- MIcombine(with(design.unw, svyby(~posmarg, ~lap, svyciprop, vartype="var")))
#Rubins rule
X2unw <- sum(mapply(function(x) x$statistic, lapply(with(design.unw, svytable(~lap + posmarg, Ntotal = 284, round = T)), prop.test)))/5

```

#Weighted univariate output
```{r,results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
pander(summary(postopwtd, digits = 2))
pander(summary(postopunw, digits = 2))
pander(summary(posmargwtd, digits =2))
pander(pchisq(X2wtd, 1, lower.tail = F))
pander(summary(posmargunw, digits = 2))
pander(pchisq(X2unw, 1, lower.tail = F))

```


#KM survival and follow-up
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#Cohort Median follow-up time by KMPF (reverse kaplan meier)
med.fu <- with(midata,survfit(Surv(cens_time, cens==0)~1+cluster(id_patients), weights = stable.w, subset=index==1))
med.fu %>%
  list.apply(summary) %>%
  list.map(table) %>%
  list.mapv(median) %>%
  (function (x) {
    mfu <-round(sum(x)/5/365.25*12, 2)
    str_c("Median follow-up (reverse KM method): ",mfu," months")
  }) -> mfu

#Cohort Median OS
cohortmedian <-with(midata,survfit(Surv(cens_time, cens)~cluster(id_patients), weights = stable.w, subset=index==1))
cohortmedian %>%
  list.apply(summary) %>%
  list.map(table) %>%
  list.mapv(median) %>%
  {
    os <-round(sum(.)/5/365.25*12, 2)
    str_c("Median OS (cohort): ",os," months")
  } -> cohortmedos
pool.kmos <- with(midata,survfit(Surv(cens_time, cens)~lap+cluster(id_patients), weights = stable.w, subset=index==1))

#OS---------------
#Median OS 
#in output results

#OS Peto-Peto modification of Gehan-Wilcoxon test (log rank), lichtrub p-val test (not perfect)
lros <- with(design.ate, svylogrank(Surv(cens_time, cens)~lap))

#5yr OS
pool.km5yr <- list.apply(pool.kmos, summary, times=1826.25)
pool5.open <- pool.scalar(list.mapv(pool.km5yr, surv[1]), list.mapv(pool.km5yr, std.err[1]^2), method="rubin")
pool5.lap <- pool.scalar(list.mapv(pool.km5yr, surv[2]), list.mapv(pool.km5yr, std.err[2]^2), method="rubin")
fiveyropen <- mi.ci(pool5.open)
fiveryrlap <- mi.ci(pool5.lap)

#------------------OS

#RFS-----------------
#RFS strata by index - gaptime is what we want to know - recurrence after each operation
rfskm <- with(midata, survfit(Surv(gaptime, (rec==1|censrec==1))~lap + strata(index) +cluster(id_patients), weights = stable.w))

cohortrfs <- with(midata, survfit(Surv(gaptime, (rec==1|censrec==1))~strata(index) +cluster(id_patients), weights = stable.w))


#logrank RFS
lrrfs <- with(design.ate, svylogrank(Surv(gaptime, (rec==1|censrec==1))~lap+strata(index)))


#5yr RFS
pool.rfs <- list.apply(rfskm, summary, times=1826.25)
pool5rfs.open <- pool.scalar(list.mapv(pool.rfs, surv[1]), list.mapv(pool.rfs, std.err[1]^2), method="rubin")
pool5rfs.lap <- pool.scalar(list.mapv(pool.rfs, surv[2]), list.mapv(pool.rfs, std.err[2]^2), method="rubin")
fiveyropenrfs <- mi.ci(pool5rfs.open)
fiveryrlaprfs <- mi.ci(pool5rfs.lap)

#--------------RFS

#Procedure based recurrence risk-------

#compare only the first OR only the second procedures - km, weighted log-rank, combined chisq
ind1 <- subset(design.ate, index==1) 
ind2 <- subset(design.ate, index==2)

rfs.km.ind1 <- with(midata, survfit(Surv(gaptime, (rec==1|censrec==1))~lap+cluster(id_patients), subset=index==1, weights=stable.w))

rfs.ind1 <- with(ind1, svylogrank(Surv(gaptime, (rec==1|censrec==1))~lap))


rfs.km.ind2 <- with(midata, survfit(Surv(gaptime, (rec==1|censrec==1))~lap+cluster(id_patients), subset=index==2, weights=stable.w))

rfs.ind2 <- with(ind2, svylogrank(Surv(gaptime, (rec==1|censrec==1))~lap))


```

#KM output

```{r, results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#Median FU
mfu

#OS
pander(cohortmedos)
pander(pool.km(pool.kmos), style="rmarkdown")
pander(micombine.chisquare(list.mapv(list.map(lros, list.extract(.,2)),chisq),1))


str_c("Open ", fiveyropen, "\n")
str_c("Laparoscopic ", fiveryrlap)

#Median RFS 
pander(pool.km(rfskm), caption = "Kaplan-Meier RFS", style="rmarkdown")
pander(micombine.chisquare(list.mapv(list.map(lrrfs, list.extract(.,2)),chisq),1))

#5yr RFS
pander(str_c("Open ", fiveyropenrfs))
pander(str_c("Laparoscopic ", fiveryrlaprfs))

#RFS by procedure number
#Index 1
pander(pool.km(rfs.km.ind1))
pander(micombine.chisquare(list.mapv(list.map(rfs.ind1, list.extract(.,2)),chisq),1))
#Index2
pander(pool.km(rfs.km.ind2))
pander(micombine.chisquare(list.mapv(list.map(rfs.ind2, list.extract(.,2)),chisq),1))

```

#Weighted regression
```{r, results='hide', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#OS-------------
#For the double robust - compare the "full model" correcting for all vars >0.2 in the PS model vs treatment only model.

#Full model
doublerobust.full <- with(midata, coxph(Surv(time, ctime,censrec)~lap+cluster(id_patients)+ismajor+isbilateral+primaryN+primaryT+lesioncount, weights = stable.w))

#Rx only model
doublerobust.final <- with(midata, coxph(Surv(time, ctime,censrec)~lap+cluster(id_patients), weights = stable.w))

#Reduced model
#doublerobust.final <- with(midata, coxph(Surv(time, ctime,censrec)~lap+cluster(id_patients)+primaryT, weights = stable.w))



#OS---------------


#RFS - PWP-CT model-------------
rec_double.full <- with(midata, coxph(Surv(gaptime,(rec==1|censrec==1))~lap+ismajor+isbilateral+primaryN+lesioncount+primaryT + strata(index), weights = stable.w))

rec_double.final <- with(midata, coxph(Surv(gaptime,(rec==1|censrec==1))~lap + strata(index), weights = stable.w))


#RFS-----------------------------

#Multivariate models------------
mvr.os  <- with(midata, coxph(Surv(time, ctime,censrec)~lap+cluster(id_patients)+ismajor+isbilateral+primaryN+lesioncount+primaryT+bloodloss+mhlos+optime+posmarg, weights = stable.w))

mvr.os.raw <- coxph(Surv(time, ctime,censrec)~lap+cluster(id_patients)+ismajor+isbilateral+primaryN+lesioncount+primaryT+bloodloss+mhlos+optime+posmarg, data=new)

mvr.rfs <- with(midata, coxph(Surv(gaptime,(rec==1|censrec==1))~lap+cluster(id_patients)+ismajor+isbilateral+primaryN+lesioncount+primaryT+bloodloss+mhlos+optime+strata(index)+posmarg, weights = stable.w))

mvr.rfs.raw <- coxph(Surv(gaptime,(rec==1|censrec==1))~lap+cluster(id_patients)+ismajor+isbilateral+primaryN+lesioncount+primaryT+bloodloss+mhlos+optime+strata(index)+posmarg, data=new)
#------------------------------

########Final multivariate models

os_final <- with(midata, coxph(Surv(time, ctime,cens)~cluster(id_patients)+primaryT+posmarg+lap+lesioncount, weights = stable.w))

raw.os.final <- coxph(Surv(time, ctime, cens)~cluster(id_patients)+primaryT+posmarg+lesioncount+lap, data=new)

rfs_final <- with(midata, coxph(Surv(gaptime, (rec==1|censrec==1))~cluster(id_patients)+primaryT+posmarg+lap, weights = stable.w))

raw.rfs.final <- coxph(Surv(gaptime, (rec==1|censrec==1))~cluster(id_patients)+primaryT+posmarg+lap, data=new)

###Print setup

os.final.data <- plotdf(os_final)
raw.os.data <- tidy(raw.os.final)

rfs.final.data <- plotdf(rfs_final)
raw.rfs.data <- tidy(raw.rfs.final)
```

```{r}
pander(spm(doublerobust.full)) #full os doublerobust
pander(spm(doublerobust.final)) #final os double robust

pander(spm(rec_double.full)) #full Rfs doublerobust
pander(spm(rec_double.final)) #final rfs double robust

pander(spm(mvr.os)) #full os multivar 
pander(mvr.os.raw) #full rfs multivar
pander(spm(mvr.rfs))
pander(mvr.rfs.raw)

pander(spm(os_final)) #final os multivar
pander(spm(rfs_final)) #final rfs multivar

```


#Regression output
```{r, results='asis', warning=FALSE, error=FALSE, message=FALSE, echo=FALSE}
#kable(os.final.data[,c(2,6,7,8)], align = 'l')
#kable(rfs.final.data[,c(2,6,7,8)], align = 'l')
source("new_os_surv_curv.R")
source("new_rfs_surv_curv.R")
os_curve
rfs_curve
```